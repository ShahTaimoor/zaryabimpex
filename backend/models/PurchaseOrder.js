const mongoose = require('mongoose');

const purchaseOrderItemSchema = new mongoose.Schema({
  product: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Product',
    required: true
  },
  quantity: {
    type: Number,
    required: true,
    min: 1
  },
  costPerUnit: {
    type: Number,
    required: true,
    min: 0
  },
  totalCost: {
    type: Number,
    required: true,
    min: 0
  },
  receivedQuantity: {
    type: Number,
    default: 0,
    min: 0
  },
  remainingQuantity: {
    type: Number,
    default: function() {
      return this.quantity - (this.receivedQuantity || 0);
    },
    min: 0
  }
});

const purchaseOrderSchema = new mongoose.Schema({
  // Basic Information
  poNumber: {
    type: String,
    required: true,
    unique: true,
    uppercase: true
  },
  supplier: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Supplier',
    required: true
  },
  
  // Order Details
  items: [purchaseOrderItemSchema],
  
  // Financial Information
  subtotal: {
    type: Number,
    required: true,
    min: 0
  },
  tax: {
    type: Number,
    default: 0,
    min: 0
  },
  isTaxExempt: {
    type: Boolean,
    default: true
  },
  total: {
    type: Number,
    required: true,
    min: 0
  },
  
  // Status and Workflow
  status: {
    type: String,
    enum: ['draft', 'confirmed', 'partially_received', 'fully_received', 'cancelled', 'closed'],
    default: 'draft'
  },
  
  // Dates
  orderDate: {
    type: Date,
    default: Date.now
  },
  expectedDelivery: {
    type: Date
  },
  confirmedDate: {
    type: Date
  },
  lastReceivedDate: {
    type: Date
  },
  
  // Additional Information
  notes: {
    type: String,
    trim: true,
    maxlength: 1000
  },
  terms: {
    type: String,
    trim: true
  },
  
  // Conversion Tracking
  conversions: [{
    convertedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true
    },
    convertedAt: {
      type: Date,
      default: Date.now
    },
    items: [{
      product: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Product'
      },
      quantity: Number,
      costPerUnit: Number,
      status: {
        type: String,
        enum: ['success', 'error'],
        default: 'success'
      },
      error: String
    }],
    notes: {
      type: String,
      trim: true
    }
  }],
  
  // Audit
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  lastModifiedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  
  // Auto-generation tracking
  isAutoGenerated: {
    type: Boolean,
    default: false
  },
  autoGeneratedAt: {
    type: Date
  },
  
  // Soft Delete Fields
  isDeleted: {
    type: Boolean,
    default: false,
    index: true
  },
  deletedAt: {
    type: Date,
    default: null
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes for better performance
// poNumber index removed - already has unique: true in field definition
purchaseOrderSchema.index({ supplier: 1, status: 1 });
purchaseOrderSchema.index({ status: 1, orderDate: -1 });
purchaseOrderSchema.index({ createdBy: 1 });
purchaseOrderSchema.index({ createdAt: -1 }); // For date range queries
purchaseOrderSchema.index({ supplier: 1, createdAt: -1 }); // For supplier order history
purchaseOrderSchema.index({ status: 1, createdAt: -1 }); // For status-based queries
purchaseOrderSchema.index({ total: -1 }); // For sorting by total

// Virtual for progress percentage
purchaseOrderSchema.virtual('progressPercentage').get(function() {
  if (this.items.length === 0) return 0;
  
  const totalOrdered = this.items.reduce((sum, item) => sum + item.quantity, 0);
  const totalReceived = this.items.reduce((sum, item) => sum + item.receivedQuantity, 0);
  
  return Math.round((totalReceived / totalOrdered) * 100);
});

// Virtual for remaining items count
purchaseOrderSchema.virtual('remainingItemsCount').get(function() {
  return this.items.filter(item => item.remainingQuantity > 0).length;
});

// Virtual for total remaining value
purchaseOrderSchema.virtual('remainingValue').get(function() {
  return this.items.reduce((sum, item) => 
    sum + (item.remainingQuantity * item.costPerUnit), 0);
});

// Method to check if PO is fully received
purchaseOrderSchema.methods.isFullyReceived = function() {
  return this.items.every(item => item.remainingQuantity === 0);
};

// Method to check if PO is partially received
purchaseOrderSchema.methods.isPartiallyReceived = function() {
  const hasReceived = this.items.some(item => item.receivedQuantity > 0);
  const hasRemaining = this.items.some(item => item.remainingQuantity > 0);
  return hasReceived && hasRemaining;
};

// Method to update item quantities after receiving
purchaseOrderSchema.methods.updateReceivedQuantities = function(receivedItems) {
  receivedItems.forEach(receivedItem => {
    const poItem = this.items.id(receivedItem.productId);
    if (poItem) {
      const newReceivedQty = poItem.receivedQuantity + receivedItem.quantity;
      poItem.receivedQuantity = Math.min(newReceivedQty, poItem.quantity);
      poItem.remainingQuantity = poItem.quantity - poItem.receivedQuantity;
    }
  });
  
  // Update status based on received quantities
  if (this.isFullyReceived()) {
    this.status = 'fully_received';
  } else if (this.isPartiallyReceived()) {
    this.status = 'partially_received';
  }
  
  this.lastReceivedDate = new Date();
  return this.save();
};

// Pre-save middleware to calculate totals
purchaseOrderSchema.pre('save', function(next) {
  // Calculate item totals
  this.items.forEach(item => {
    item.totalCost = item.quantity * item.costPerUnit;
    item.remainingQuantity = item.quantity - item.receivedQuantity;
  });
  
  // Calculate order totals
  this.subtotal = this.items.reduce((sum, item) => sum + item.totalCost, 0);
  this.total = this.subtotal + this.tax;
  
  next();
});

// Static method to generate PO number
purchaseOrderSchema.statics.generatePONumber = function() {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const time = String(now.getTime()).slice(-4);
  
  return `PO-${year}${month}${day}-${time}`;
};

module.exports = mongoose.model('PurchaseOrder', purchaseOrderSchema);
